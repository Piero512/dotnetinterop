// ignore_for_file: always_specify_types, constant_identifier_names
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

/// Bindings for hostfxr interop.
///
/// Regenerate bindings with `flutter pub run ffigen --config hostfxr.yaml`.
///
class HostFXR {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  HostFXR(ffi.DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  HostFXR.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// Sets a callback which is to be used to write errors to.
  ///
  /// Parameters:
  /// error_writer
  /// A callback function which will be invoked every time an error is to be reported.
  /// Or nullptr to unregister previously registered callback and return to the default behavior.
  /// Return value:
  /// The previously registered callback (which is now unregistered), or nullptr if no previous callback
  /// was registered
  ///
  /// The error writer is registered per-thread, so the registration is thread-local. On each thread
  /// only one callback can be registered. Subsequent registrations overwrite the previous ones.
  ///
  /// By default no callback is registered in which case the errors are written to stderr.
  ///
  /// Each call to the error writer is sort of like writing a single line (the EOL character is omitted).
  /// Multiple calls to the error writer may occur for one failure.
  ///
  /// If the hostfxr invokes functions in hostpolicy as part of its operation, the error writer
  /// will be propagated to hostpolicy for the duration of the call. This means that errors from
  /// both hostfxr and hostpolicy will be reporter through the same error writer.
  ffi.Pointer<hostfxr_error_writer_fn> hostfxr_set_error_writer_fn(
    hostfxr_error_writer_fn error_writer,
  ) {
    return _hostfxr_set_error_writer_fn(
      error_writer,
    );
  }

  late final _hostfxr_set_error_writer_fnPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<hostfxr_error_writer_fn> Function(
              hostfxr_error_writer_fn)>>('hostfxr_set_error_writer_fn');
  late final _hostfxr_set_error_writer_fn =
      _hostfxr_set_error_writer_fnPtr.asFunction<
          ffi.Pointer<hostfxr_error_writer_fn> Function(
              hostfxr_error_writer_fn)>();

  /// Initializes the hosting components for a dotnet command line running an application
  ///
  /// Parameters:
  /// argc
  /// Number of argv arguments
  /// argv
  /// Command-line arguments for running an application (as if through the dotnet executable).
  /// Only command-line arguments which are accepted by runtime installation are supported, SDK/CLI commands are not supported.
  /// For example 'app.dll app_argument_1 app_argument_2`.
  /// parameters
  /// Optional. Additional parameters for initialization
  /// host_context_handle
  /// On success, this will be populated with an opaque value representing the initialized host context
  ///
  /// Return value:
  /// Success          - Hosting components were successfully initialized
  /// HostInvalidState - Hosting components are already initialized
  ///
  /// This function parses the specified command-line arguments to determine the application to run. It will
  /// then find the corresponding .runtimeconfig.json and .deps.json with which to resolve frameworks and
  /// dependencies and prepare everything needed to load the runtime.
  ///
  /// This function only supports arguments for running an application. It does not support SDK commands.
  ///
  /// This function does not load the runtime.
  int hostfxr_initialize_for_dotnet_command_line_fn(
    int argc,
    ffi.Pointer<ffi.Pointer<char_t>> argv,
    ffi.Pointer<hostfxr_initialize_parameters> parameters,
    ffi.Pointer<hostfxr_handle> host_context_handle,
  ) {
    return _hostfxr_initialize_for_dotnet_command_line_fn(
      argc,
      argv,
      parameters,
      host_context_handle,
    );
  }

  late final _hostfxr_initialize_for_dotnet_command_line_fnPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  ffi.Int,
                  ffi.Pointer<ffi.Pointer<char_t>>,
                  ffi.Pointer<hostfxr_initialize_parameters>,
                  ffi.Pointer<hostfxr_handle>)>>(
      'hostfxr_initialize_for_dotnet_command_line_fn');
  late final _hostfxr_initialize_for_dotnet_command_line_fn =
      _hostfxr_initialize_for_dotnet_command_line_fnPtr.asFunction<
          int Function(
              int,
              ffi.Pointer<ffi.Pointer<char_t>>,
              ffi.Pointer<hostfxr_initialize_parameters>,
              ffi.Pointer<hostfxr_handle>)>();

  /// Initializes the hosting components using a .runtimeconfig.json file
  ///
  /// Parameters:
  /// runtime_config_path
  /// Path to the .runtimeconfig.json file
  /// parameters
  /// Optional. Additional parameters for initialization
  /// host_context_handle
  /// On success, this will be populated with an opaque value representing the initialized host context
  ///
  /// Return value:
  /// Success                            - Hosting components were successfully initialized
  /// Success_HostAlreadyInitialized     - Config is compatible with already initialized hosting components
  /// Success_DifferentRuntimeProperties - Config has runtime properties that differ from already initialized hosting components
  /// CoreHostIncompatibleConfig         - Config is incompatible with already initialized hosting components
  ///
  /// This function will process the .runtimeconfig.json to resolve frameworks and prepare everything needed
  /// to load the runtime. It will only process the .deps.json from frameworks (not any app/component that
  /// may be next to the .runtimeconfig.json).
  ///
  /// This function does not load the runtime.
  ///
  /// If called when the runtime has already been loaded, this function will check if the specified runtime
  /// config is compatible with the existing runtime.
  ///
  /// Both Success_HostAlreadyInitialized and Success_DifferentRuntimeProperties codes are considered successful
  /// initializations. In the case of Success_DifferentRuntimeProperties, it is left to the consumer to verify that
  /// the difference in properties is acceptable.
  int hostfxr_initialize_for_runtime_config(
    ffi.Pointer<char_t> runtime_config_path,
    ffi.Pointer<hostfxr_initialize_parameters> parameters,
    ffi.Pointer<hostfxr_handle> host_context_handle,
  ) {
    return _hostfxr_initialize_for_runtime_config(
      runtime_config_path,
      parameters,
      host_context_handle,
    );
  }

  late final _hostfxr_initialize_for_runtime_configPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  ffi.Pointer<char_t>,
                  ffi.Pointer<hostfxr_initialize_parameters>,
                  ffi.Pointer<hostfxr_handle>)>>(
      'hostfxr_initialize_for_runtime_config');
  late final _hostfxr_initialize_for_runtime_config =
      _hostfxr_initialize_for_runtime_configPtr.asFunction<
          int Function(
              ffi.Pointer<char_t>,
              ffi.Pointer<hostfxr_initialize_parameters>,
              ffi.Pointer<hostfxr_handle>)>();

  /// Gets the runtime property value for an initialized host context
  ///
  /// Parameters:
  /// host_context_handle
  /// Handle to the initialized host context
  /// name
  /// Runtime property name
  /// value
  /// Out parameter. Pointer to a buffer with the property value.
  ///
  /// Return value:
  /// The error code result.
  ///
  /// The buffer pointed to by value is owned by the host context. The lifetime of the buffer is only
  /// guaranteed until any of the below occur:
  /// - a 'run' method is called for the host context
  /// - properties are changed via hostfxr_set_runtime_property_value
  /// - the host context is closed via 'hostfxr_close'
  ///
  /// If host_context_handle is nullptr and an active host context exists, this function will get the
  /// property value for the active host context.
  int hostfxr_get_runtime_property_value_fn(
    hostfxr_handle host_context_handle,
    ffi.Pointer<char_t> name,
    ffi.Pointer<ffi.Pointer<char_t>> value,
  ) {
    return _hostfxr_get_runtime_property_value_fn(
      host_context_handle,
      name,
      value,
    );
  }

  late final _hostfxr_get_runtime_property_value_fnPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(hostfxr_handle, ffi.Pointer<char_t>,
                  ffi.Pointer<ffi.Pointer<char_t>>)>>(
      'hostfxr_get_runtime_property_value_fn');
  late final _hostfxr_get_runtime_property_value_fn =
      _hostfxr_get_runtime_property_value_fnPtr.asFunction<
          int Function(hostfxr_handle, ffi.Pointer<char_t>,
              ffi.Pointer<ffi.Pointer<char_t>>)>();

  /// Sets the value of a runtime property for an initialized host context
  ///
  /// Parameters:
  /// host_context_handle
  /// Handle to the initialized host context
  /// name
  /// Runtime property name
  /// value
  /// Value to set
  ///
  /// Return value:
  /// The error code result.
  ///
  /// Setting properties is only supported for the first host context, before the runtime has been loaded.
  ///
  /// If the property already exists in the host context, it will be overwritten. If value is nullptr, the
  /// property will be removed.
  ffi.Pointer<ffi.Int32> hostfxr_set_runtime_property_value_fn(
    hostfxr_handle host_context_handle,
    ffi.Pointer<char_t> name,
    ffi.Pointer<char_t> value,
  ) {
    return _hostfxr_set_runtime_property_value_fn(
      host_context_handle,
      name,
      value,
    );
  }

  late final _hostfxr_set_runtime_property_value_fnPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Int32> Function(hostfxr_handle, ffi.Pointer<char_t>,
              ffi.Pointer<char_t>)>>('hostfxr_set_runtime_property_value_fn');
  late final _hostfxr_set_runtime_property_value_fn =
      _hostfxr_set_runtime_property_value_fnPtr.asFunction<
          ffi.Pointer<ffi.Int32> Function(
              hostfxr_handle, ffi.Pointer<char_t>, ffi.Pointer<char_t>)>();

  /// Gets all the runtime properties for an initialized host context
  ///
  /// Parameters:
  /// host_context_handle
  /// Handle to the initialized host context
  /// count
  /// [in] Size of the keys and values buffers
  /// [out] Number of properties returned (size of keys/values buffers used). If the input value is too
  /// small or keys/values is nullptr, this is populated with the number of available properties
  /// keys
  /// Array of pointers to buffers with runtime property keys
  /// values
  /// Array of pointers to buffers with runtime property values
  ///
  /// Return value:
  /// The error code result.
  ///
  /// The buffers pointed to by keys and values are owned by the host context. The lifetime of the buffers is only
  /// guaranteed until any of the below occur:
  /// - a 'run' method is called for the host context
  /// - properties are changed via hostfxr_set_runtime_property_value
  /// - the host context is closed via 'hostfxr_close'
  ///
  /// If host_context_handle is nullptr and an active host context exists, this function will get the
  /// properties for the active host context.
  ffi.Pointer<ffi.Int32> hostfxr_get_runtime_properties_fn(
    hostfxr_handle host_context_handle,
    ffi.Pointer<ffi.Size> count,
    ffi.Pointer<ffi.Pointer<char_t>> keys,
    ffi.Pointer<ffi.Pointer<char_t>> values,
  ) {
    return _hostfxr_get_runtime_properties_fn(
      host_context_handle,
      count,
      keys,
      values,
    );
  }

  late final _hostfxr_get_runtime_properties_fnPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Int32> Function(
                  hostfxr_handle,
                  ffi.Pointer<ffi.Size>,
                  ffi.Pointer<ffi.Pointer<char_t>>,
                  ffi.Pointer<ffi.Pointer<char_t>>)>>(
      'hostfxr_get_runtime_properties_fn');
  late final _hostfxr_get_runtime_properties_fn =
      _hostfxr_get_runtime_properties_fnPtr.asFunction<
          ffi.Pointer<ffi.Int32> Function(
              hostfxr_handle,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Pointer<char_t>>,
              ffi.Pointer<ffi.Pointer<char_t>>)>();

  /// Load CoreCLR and run the application for an initialized host context
  ///
  /// Parameters:
  /// host_context_handle
  /// Handle to the initialized host context
  ///
  /// Return value:
  /// If the app was successfully run, the exit code of the application. Otherwise, the error code result.
  ///
  /// The host_context_handle must have been initialized using hostfxr_initialize_for_dotnet_command_line.
  ///
  /// This function will not return until the managed application exits.
  int hostfxr_run_app_fn(
    hostfxr_handle host_context_handle,
  ) {
    return _hostfxr_run_app_fn(
      host_context_handle,
    );
  }

  late final _hostfxr_run_app_fnPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(hostfxr_handle)>>(
          'hostfxr_run_app_fn');
  late final _hostfxr_run_app_fn =
      _hostfxr_run_app_fnPtr.asFunction<int Function(hostfxr_handle)>();

  /// Gets a typed delegate from the currently loaded CoreCLR or from a newly created one.
  ///
  /// Parameters:
  /// host_context_handle
  /// Handle to the initialized host context
  /// type
  /// Type of runtime delegate requested
  /// delegate
  /// An out parameter that will be assigned the delegate.
  ///
  /// Return value:
  /// The error code result.
  ///
  /// If the host_context_handle was initialized using hostfxr_initialize_for_runtime_config,
  /// then all delegate types are supported.
  /// If the host_context_handle was initialized using hostfxr_initialize_for_dotnet_command_line,
  /// then only the following delegate types are currently supported:
  /// hdt_load_assembly_and_get_function_pointer
  /// hdt_get_function_pointer
  int hostfxr_get_runtime_delegate(
    hostfxr_handle host_context_handle,
    int type,
    ffi.Pointer<ffi.Pointer<ffi.Void>> delegate,
  ) {
    return _hostfxr_get_runtime_delegate(
      host_context_handle,
      type,
      delegate,
    );
  }

  late final _hostfxr_get_runtime_delegatePtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(hostfxr_handle, ffi.Int32,
                  ffi.Pointer<ffi.Pointer<ffi.Void>>)>>(
      'hostfxr_get_runtime_delegate');
  late final _hostfxr_get_runtime_delegate =
      _hostfxr_get_runtime_delegatePtr.asFunction<
          int Function(
              hostfxr_handle, int, ffi.Pointer<ffi.Pointer<ffi.Void>>)>();

  /// Closes an initialized host context
  ///
  /// Parameters:
  /// host_context_handle
  /// Handle to the initialized host context
  ///
  /// Return value:
  /// The error code result.
  int hostfxr_close(
    hostfxr_handle host_context_handle,
  ) {
    return _hostfxr_close(
      host_context_handle,
    );
  }

  late final _hostfxr_closePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(hostfxr_handle)>>(
          'hostfxr_close');
  late final _hostfxr_close =
      _hostfxr_closePtr.asFunction<int Function(hostfxr_handle)>();

  /// Returns available SDKs and frameworks.
  ///
  /// Resolves the existing SDKs and frameworks from a dotnet root directory (if
  /// any), or the global default location. If multi-level lookup is enabled and
  /// the dotnet root location is different than the global location, the SDKs and
  /// frameworks will be enumerated from both locations.
  ///
  /// The SDKs are sorted in ascending order by version, multi-level lookup
  /// locations are put before private ones.
  ///
  /// The frameworks are sorted in ascending order by name followed by version,
  /// multi-level lookup locations are put before private ones.
  ///
  /// Parameters:
  /// dotnet_root
  /// The path to a directory containing a dotnet executable.
  ///
  /// reserved
  /// Reserved for future parameters.
  ///
  /// result
  /// Callback invoke to return the list of SDKs and frameworks.
  /// Structs and their elements are valid for the duration of the call.
  ///
  /// result_context
  /// Additional context passed to the result callback.
  ///
  /// Return value:
  /// 0 on success, otherwise failure.
  ///
  /// String encoding:
  /// Windows     - UTF-16 (pal::char_t is 2 byte wchar_t)
  /// Unix        - UTF-8  (pal::char_t is 1 byte char)
  int hostfxr_get_dotnet_environment_info(
    ffi.Pointer<char_t> dotnet_root,
    ffi.Pointer<ffi.Void> reserved,
    hostfxr_get_dotnet_environment_info_result_fn result,
    ffi.Pointer<ffi.Void> result_context,
  ) {
    return _hostfxr_get_dotnet_environment_info(
      dotnet_root,
      reserved,
      result,
      result_context,
    );
  }

  late final _hostfxr_get_dotnet_environment_infoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<char_t>,
              ffi.Pointer<ffi.Void>,
              hostfxr_get_dotnet_environment_info_result_fn,
              ffi.Pointer<ffi.Void>)>>('hostfxr_get_dotnet_environment_info');
  late final _hostfxr_get_dotnet_environment_info =
      _hostfxr_get_dotnet_environment_infoPtr.asFunction<
          int Function(
              ffi.Pointer<char_t>,
              ffi.Pointer<ffi.Void>,
              hostfxr_get_dotnet_environment_info_result_fn,
              ffi.Pointer<ffi.Void>)>();
}

abstract class hostfxr_delegate_type {
  static const int hdt_com_activation = 0;
  static const int hdt_load_in_memory_assembly = 1;
  static const int hdt_winrt_activation = 2;
  static const int hdt_com_register = 3;
  static const int hdt_com_unregister = 4;
  static const int hdt_load_assembly_and_get_function_pointer = 5;
  static const int hdt_get_function_pointer = 6;
}

/// Predeclaration.
class hostfxr_dotnet_environment_info extends ffi.Struct {
  @ffi.Size()
  external int size;

  external ffi.Pointer<char_t> hostfxr_version;

  external ffi.Pointer<char_t> hostfxr_commit_hash;

  @ffi.Size()
  external int sdk_count;

  external ffi.Pointer<hostfxr_dotnet_environment_sdk_info> sdks;

  @ffi.Size()
  external int framework_count;

  external ffi.Pointer<hostfxr_dotnet_environment_framework_info> frameworks;
}

typedef char_t = ffi.WChar;

class hostfxr_dotnet_environment_sdk_info extends ffi.Struct {
  @ffi.Size()
  external int size;

  external ffi.Pointer<char_t> version;

  external ffi.Pointer<char_t> path;
}

class hostfxr_dotnet_environment_framework_info extends ffi.Struct {
  @ffi.Size()
  external int size;

  external ffi.Pointer<char_t> name;

  external ffi.Pointer<char_t> version;

  external ffi.Pointer<char_t> path;
}

typedef hostfxr_error_writer_fn
    = ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<char_t>)>>;

class hostfxr_initialize_parameters extends ffi.Struct {
  @ffi.Size()
  external int size;

  external ffi.Pointer<char_t> host_path;

  external ffi.Pointer<char_t> dotnet_root;
}

typedef hostfxr_handle = ffi.Pointer<ffi.Void>;
typedef hostfxr_get_dotnet_environment_info_result_fn = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<hostfxr_dotnet_environment_info>,
            ffi.Pointer<ffi.Void>)>>;
